# C++内存分配
## 学习C/C++程序内存的各种变量存储区域和各个区域详解
学习资料：[什么是代码区、常量区、静态区（全局区）、堆区、栈区？](https://blog.csdn.net/u014470361/article/details/79297601)
[C/C++程序内存的各种变量存储区域和各个区域详解](https://blog.csdn.net/jirryzhang/article/details/79518408)
[C/C++分区详解](https://blog.csdn.net/qq_44688854/article/details/106115161)
[C++中内存分配](https://zhuanlan.zhihu.com/p/447356030)
[堆栈、BSS段、代码段、数据段、RO、RW、ZI等概念区分](https://blog.csdn.net/dfl448866/article/details/90444228)

&emsp;内存分区：分语言层面和CPU层面进行了解，也可理解为C++在win和Linux上的内存分区。
对于运行在Linux的C++程序，C++和Linux虚拟内存的内存分布中栈区、堆区和程序代码区是相互对应的。Linux虚拟内存中data段存储了C++已经初始化的全局变量和局部变量和常量。bss段存储了未初始化的全局变量和静态变量，这些未初始化的数据在程序执行前会自动被操作系统置零。

###  语言层面
内存分区示意图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/29c0e0e18a1f466db5d9d876124f4265.png)
C/C++五大内存分区(内存由高到低)：
  1、栈区（stack）:存放函数形参和局部变量（auto类型），由编译器自动分配和释放。
  2、堆区（heap）:该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。如果程序员没有手动释放，那么程序结束时可能由OS回收。
  3、静态存储区：存放全局变量和静态变量（包括静态全局变量与静态局部变量），初始化的全局变量和静态局部变量放在一块，未初始化的放在另一块。
  4、常量区：存放字符串常量与const修饰的常量，常量区的内存是只读的，程序结束后由系统释放。
  5、代码区：存放程序的二进制代码，内存由系统管理。
  
	
	学习如上的一些内存分配机制，有助于我们理解指针的概念。

<p>
<p>
<p>

### 区域介绍
**栈区：** 存放函数内的局部变量，函数参数、返回数据、返回地址，栈区之中的数据作用范围过了之后，系统就会回收自动管理栈区的内存（分配内存、回收内存），不需要开发人员来手动管理（栈区的变化是一种动态的数据变动）。
**堆区：** 由程序员调用malloc()函数来主动申请，需要使用free()函数释放内存，若申请了堆区内存，之后忘记释放内存，很容易造成 **内存泄漏** 。
**静态区（全局区）**：静态变量和全局变量的存储区域是一起的，一旦静态区的内存被分配，静态区的内存直到程序全部结束之后才会被释放。
**常量区：** 存放常量（与程序在运行期间不改变的量，例如：10，字符串常量“abcde”，数组的名字等）
**代码区：** 存放程序的代码，即CPU执行的机器指令（二进制代码），并且是只读的。

<p>
<p>
<p>

#### 栈区
栈区是由编译器自动分配释放，存放函数的参数值、返回值和局部变量，在程序运行过程中实时分配和释放，栈区由操作系统自动管理，无需手动管理，栈区是先进后出原则。

```cpp
void test(){
	int a;
	int b = 1;
	printf("0x%p: %d\n", &a, a);
	printf("0x%p: %d\n", &b, b);
}
```
可以看到b的地址是比a小的，即栈区是从高地址向低地址增长。a没有赋值，编译器将其初始化为0（文章中说编译器不会把未初始化的局部变量初始化为0，但如果运行于debug调试模式，运行时机制会把栈空间全部初始化为0。使用局部变量时，尽量要先进行初始化，避免垃圾值造成影响）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c88ffb1ccb864d588eaf6be764d199d7.png)
##### 大小端测试
数据在内存中存放，有大端模式和小端模式。
小端模式（little-endian）：低位字节存在低地址上，高位字节存在高地址上。
大端模式（big-endian）：低位字节存在高地址上，低位字节存放在低地址上，与小端模式相反。
另外：网络字节序：TCP/IP各层协议将字节序定义为big-endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。

①利用指针判断大小端：
```cpp
static int m = 0x9876543210;
char *p = (char*) &m;

void test(){   
    printf("P  :0x%p: %x\n", p, *p);
    printf("P+1:0x%p: %x\n", p+1, *(p+1));
    printf("P+2:0x%p: %x\n", p+2, *(p+2));
    printf("P+3:0x%p: %x\n", p+3, *(p+3));
}
```
低字节10放在低地址，高字节76放在高地址，与小端模式相符。
![在这里插入图片描述](https://img-blog.csdnimg.cn/cd26e992b93d45db963cca81447e3dea.png)
②强制类型转换

```cpp
static int m = 0x9876543210;
char p = (char)m;
 
void test(){   
	printf("P: 0x%p\n", p);
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/d4613885c28840d2935f4833f2b56168.png)
③使用联合体进行判断
- 联合体的各个成员都是公用内存
- 联合体的成员不管是在哪个架构上默认都是从低地址存储的，这点非常重要。

```cpp
union endian{
	char a;
	int b;
}test;

int main()
{
	test.b = 0x87654321;
	printf("0x%p\n", test.a );
	return 0;
}
```
可以判断出所用的架构是小端的。因为test.a是联合体在内存中的第一个字节（就是在内存地址中的最低的地址），打印出了0x21说明数据的逻辑低位存储在了内存地址的低位，这就是小端了。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2e13b04feb5d431e8271395de4621fdf.png)

<p>
<p>
<p>

#### 堆区
堆区是调用malloc函数来申请内存空间，这部分空间使用完后需要调用free()函数来释放，否则可能会造成内存泄漏。需要注意的是，两个紧挨着定义的指针变量，所指向的malloc出来的两块内存并不一定的是紧挨着的，所以会产生内存碎片。
`void * malloc(size_t);`函数的输入是分配的字节的大小，返回是一个void * 型的指针，该指针指向分配空间的首地址，void * 型指针可以任意转换成其他类型的指针。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。

```cpp
void test(){   
    int *p1 = (int*)malloc(4);//申请4字节的空间 
    *p1 = 123;//空间赋值123 
	printf("0x%p: %d\n", p1, *p1);
	printf("0x%p\n", &p1);
	free(p1);
	printf("0x%p: %d\n", p1, *p1);
	p1 = NULL;//把指针p释放，避免造成野指针 
	printf("0x%p\n", p1);
}
```
`int *p1 = (int *)malloc(4);`语句申请了四个字节的空间，空间的首地址赋给了指针p1，可以看到首地址是0x0000000000c51530，存在是堆区。
`printf("0x%p\n", &p1);`指针p1本身也需要存放，p1本身是存放在栈区的0x00000000006ffde8;
`free(p1);`内存释放函数free(开辟的内存的首地址)，将内存标记为可用（并且将里面的内容清空为0，但是dev C++里没有变为0而是垃圾值），但指针还是指向这片空间，比较安全的做法是`p1 = NULL;`把p1指针释放，避免造成野指针。
![在这里插入图片描述](https://img-blog.csdnimg.cn/9d4cf7bddd104e2fb12e1b6044bb352e.png)

```cpp
void test(){
	int *p1 = (int *)malloc(4);
	int *p2 = (int *)malloc(4);
	printf("p1: 0x%p\n", p1);
	printf("p2: 0x%p\n", p2);
}
```
p2的地址高于p1的地址，验证了堆区是从低地址向高地址增长的，后申请的空间地址会依次增加。
![在这里插入图片描述](https://img-blog.csdnimg.cn/38d9b6f84694416aa07cfe5da9dd07ac.png)

> 内存溢出（out of memory）；通俗理解就是内存不够，通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了主机内安装的内存所承受大小，就叫内存溢出。

拓展资料（申请分配大内存）：[Linux 内存映射函数 mmap（）函数详解](https://blog.csdn.net/yangle4695/article/details/52139585)
 
<p>
<p>

##### 内存碎片
&emsp;一种解释：为了减少内存碎片的产生，编译器可能会将堆区又分为block和heap区，block由一系列大小相等的内存块组成。分配内存时先在block中分配，如果block占满则从heap区中分配。同时block的大小和个数可以通过文件进行配置，使之达到一个合适的状态。

```cpp
#define BLOCK_List\
	BLOCK(20, 80)\
	BLOCK(300, 80)
```


<p>
<p>

##### 内存泄漏
内存泄漏（Memory Leak）：是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
  
<p>
<p>
<p>
<p>
<p>

#### 静态区
和“栈”一样，通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。

```cpp
static int a;
int  c;

void test(){
	static int b = 1;
	b++;
	printf("b: 0x%p: %d\n", &b, b);
}

int main()
{
	printf("a: 0x%p: %d\n", &a, a);
	printf("c: 0x%p: %d\n", &c, c);
	for(int i = 0; i < 5; i++)
		test();	
	return 0;
}
```
a是静态全局变量，b是静态局部变量，c是全局变量，它们都存储在静态区，a和c并未初始化，打印出来的值都是0，说明编译器自动将它们初始化为0。b在for循环中打印5次，但实际是b只初始化1次，后面每次调用b都是上次的值+1且b的地址一直是不变的，编译器只会为第一次初始化的b分配内存。
![在这里插入图片描述](https://img-blog.csdnimg.cn/45565dbf276540eaa37f5808b6f8c63c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZXJjaV9mYzIzMzY=,size_13,color_FFFFFF,t_70,g_se,x_16)

#### 常量区
和全局/静态存储区一样，通常是用于那些在编译期间就能确定存储大小的常量的存储区，并且在程序运行期间，存储区内常量是全局可见的。这是一块比较特殊的存储区，它们里面存放的是常量，不允许被修改。
下面来分析一句代码：`char *p = "abcde"`。这句代码和`char *p; p = "abcde"`是等价的。
这两种定义方式的具体意思是：定义一个char * 型的指针p，p存放的是字符串常量“abcde”的首地址，字符串常量“abcde”是存放在常量区的，也就是p指向常量区，那么p指向的区域里面的内容是不可以修改的，只可以用*p来读取p指向的内容，或者将p指向其他区域。

测试：

```cpp
void test(){
	char *p = "abcde";
	printf("0x%p: %s\n", p, p);//打印指针p的地址和p指向的字符串内容
	p = "qdwoed";
	printf("0x%p: %s\n", p, p);//打印指针p的地址和p指向的字符串内容
	p[0] = 'c';			       //尝试修改p指向的第一个字符
	printf("0x%p: %s\n", p, p);//打印指针p的地址和p指向的字符串内容 
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/ad87fd67769f467683053a02bfa55f3a.png)
可以看到"abcde"字符串常量放在0x0000000000488006区域，p 指针指向该区域，然后将 p 指针指向"qdwoed”字符串常量的首地址0x0000000000488016。当尝试修改 p 指向的第一个字符时，程序运行异常并退出，因为常量区的内容不可以修改。
`char str[] = "abcde"`这句话是定义了一个字符数组，但这个str[]数组是存放在栈区的，然后再把字符串变量"abcde"拷贝到栈区的str数组内，那么此时的str是可以修改的。

```cpp
void test(){
	char str[] = "abcde";
	printf("0x%p: %s\n", str, str);
	str[0] = 'b';
	printf("0x%p: %s\n", str, str);
}
```
可以看到str是指向栈区的地址：0x00000000008efde0，且指向的内容可以被修改，第一个字符'a'被修改为'b'。
![在这里插入图片描述](https://img-blog.csdnimg.cn/e4a768949cae4ed5b696dee330dc2913.png)



#### 代码区 
- 代码区的内存是由系统控制的
- 代码区的存放：程序中的函数编译后的代码，即cpu执行的机器指令，只读。
- 代码区的地址：函数的地址，程序的入口地址，程序的名字。
	函数的名称也是一个指针，可以通过查询函数名称所处的内存地址，查询函数存放的区域。
```cpp
void print(){
	printf("hello\n");
}
void test(){
	printf("print add: 0x%p\n", print);//打印 print()函数的存放地址 
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/7cbbb195e39c436fa82c421b29457e5e.png)

<p>
<p>
<p>


#### 区域注意的点

①**C/C++不提供垃圾回收机制，因此需要对堆中的数据进行及时销毁，防止内存泄漏**，使用 free 和 delete 销毁 new 和 malloc 申请的堆内存，而栈内存是动态释放。

②堆区一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式类似于链表。

③普通局部变量保存在堆栈中，每个线程都会有自己的栈，但是堆空间是共用的。

④全局变量、静态变量保存在全局数据区，初始化的和未初始化的分别保存在一起。

<p>
<p>
<p>
<p>
<p>
<p>

### CPU层面
对于CPU来说，程序在内存中的分区定义略有不同。一个程序在内存中的分区可分：
1、text segment（代码段）：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码
2、data segment（数据段）：存储程序中以初始化的全局变量和静态变量
3、bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。对于未初始化的的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0
4、heap（堆）：当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。堆的起始地址由mm_struct结构体中的start_brk标识，结束地址由brk标识。
5、stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。

<p>
<p>

#### 文件分区
一个可执行的程序文件可分为三部分：text 、data、bss。这三部分是在编译时就确定分配的空间，属于静态空间，所以被包含在可执行文件里；其余动态空间（局部变量，new分配的空间）在程序执行时分配，所以不包含在可执行文件里。
 1、text segment（代码段）：用来存放代码，一般是只读的区域;
 2、data segment（数据段）：用来存放const修饰的常量、初始化的全局变量、静态变量，只初始化一次。data又可分为RO_data(const修饰的常量)和RW_data(初始化的全局变量、静态变量);
 3、bss segment：bss又叫ZI-data，用来存放未初始化的全局变量和静态变量，以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。

<p>
<p>
	
#### 静态区域
##### **text segment（代码段）**
代码段（又称为Code代码域）存放程序执行代码的一段内存区域，这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读（某些架构也允许修改）。
- 文本区存储程序的机器代码（二进制代码）
- 这块内存是**共享**的，当多个相同进程（Process）存在时，共用同一个text段
- 所有函数都是存储在代码段
- 代码段中的指令包括操作码和被操作对象（或对象地址引用）
	- 只读变量：只包含在代码段中
	- 局部变量：在堆栈区分配内存空间并引用
	- 全局变量：引用data段或bss段中的地址

<p>

###### 常量数据段（.rodata）
RO表示read only，用于存放不可修改的常量数据，一旦程序中对其修改将会出现段错误。
用于维护只读数据，比如：常量字符串、带 const 修饰的全局变量和静态变量等，在目标文件中占据空间。
（1）程序中的常量不一定就放在.rodata里，有的立即数和指令编码放在.text中。
（2）对于字符串常量，若程序中存在重复的字符串，编译器会**自动去掉重复的字符串**，保证一个字符串在一个可执行文件（EXE/SO）中只存在一份拷贝。
（3）.rodata是在多个进程间共享的。
（4）想将数据（变量）放在.rodata区只需要加上const属性修饰即可

拓展：[七种寻址方式](https://blog.csdn.net/u011587070/article/details/81540987)

<p>
<p>

##### data segment（数据段）
&emsp;存储程序中**已初始化**的**全局变量**和**静态变量**。也有地方叫GVAR(global value)
   - data又可以分为读写区域(RW_data)和只读区域(RO_data)
	- RO段：ReadOnly data，即只读数据域，它指程序中用到的只读数据，全局变量，例如C语言中const关键字定义的全局变量就是典型的RO-data。RO段保存常量所以也被称为`.constdata`。
	- RW段：ReadWrite data，即可读写数据域，它指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。例如全局变量或者静态变量，且定义时赋予“非0值”给该变量进行初始化。	- 
RW_data：

<p>
<p>

##### bss segment（bss段）
&emsp; 存储未初始化的全局变量和静态变量，以及所有被初始为0的全局变量和静态变量，程序运行main之前时会统一清零。**即未初始化的全局变量和静态变量编译器会初始化为0**

<p>
<p>
<p>
<p>

#### 动态区域
&emsp;**heap（堆）**：当进程未调用malloc时是没有堆段的，**只有调用malloc时采用分配一个堆**，并且在程序运行过程中可以动态增加堆的大小（移动break指针），**从低地址向高地址增长**。**分配小内存时使用该区域**。
&emsp;**memory mapping segment（映射区）：** 存储动态链接库等文件、申请大内存（malloc时调用mmap函数），位于堆和栈之间。
&emsp;**stack（栈）**：使用栈空间存储函数的返回地址、参数、局部变量、返回值。**从高地址向低地址增长**。**在创建进程时会有一个最大栈大小，** Linux可以通过ulimit命令指定。.esp始终指向栈顶。
	
- 其他
	- 栈的大小是有限的，通常Visual C++编译器默认栈的大小为1MB
	- 堆的大小几乎不受限制，理论上每个程序最大可达4GB。
	- 堆和栈相向而生，栈和堆有个临界点，称为stkbrk。
	- 相同：堆、栈都是动态分配内存，两者空间的大小是可变的。
	- 不同：每个线程都有自己的栈，但是堆空间是共用的。


<p>

##### 堆、栈
|     区别                                                             |        栈               |      堆               |
| ------------------------------------------------------------| --------------------  |--------------------|
|管理方式|编译器自动分配释放|程序员分配释放，容易产生内存泄漏|
|空间大小|一般有一定的空间限制（比如1M）|在32位系统下堆内存可以达到4G大小，空间足够大|
|内存碎片|不存在碎片问题|存在内存碎片问题|
|生长方向|栈向着内存地址减小的方向生长（由高到低）|堆向着内存地址增加的方向生长（由低到高）|
|分配方法|静态分配，由编译器完成（比如分配局部变量）|动态分配由malloc函数进行分配，无静态分配|
|分配效率|栈是操作系统提供的数据结构，计算机会在底层对栈提供支持（比如分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行），分配效率高|堆是C/C++函数库提供的，实现机制比较复杂（比如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大的空间，当没有合适的空间（比如内存碎片太多）时可能通过系统调用去增加堆段的内存空间），分配效率较低|
|系统响应|只要栈的剩余空间大于所申请空间就可以分配成功，否则就抛出栈溢出的异常|操作系统存在一个记录空闲内存地址的链表，分配堆内存时会遍历链表寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。大多数系统还会在这块内存空间中的首地址记录本次分配的大小，这样delete语句才能正确释放本内存空间。由于找到的堆节点大小不一定正好等于申请内存的大小，因此系统会自动将多余的部分重新放入空闲链表中|
|存储内容|在函数调用时，第一个入栈的是函数调用语句的下一条可执行语句的地址，然后是函数的各个参数，最后是函数中的局部变量。本次函数调用结束后，按照先进后出的方式依次弹出局部变量、函数参数和栈顶指针。程序根据栈顶指针指向的地址继续运行|一般在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排|
|内存越界|栈内存越界情况大多出现在数组下标超过数组定义长度，后果导致覆盖其他变量|堆内存越界主要是操作的内存超过了malloc/calloc/new等在堆上分配内存的内存大小，后果导致下次分配时抛出`_int_malloc`错误，中止|

和栈相比，堆存在以下缺点：
- 由于大量new/delete的使用容易产生大量的内存碎片问题
- 没有专门的系统支持，分配效率较低
- 可能引发用户态和核心态的切换

总结：
- stack：按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。
- heap：自由申请的空间，按内存地址从低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。

<p>
<p>
<p>

#### 总结
以上几个概念的对应关系如下表中所示：
备注:粉色部分的code和RO_data文字颜色为灰色，表示可能发生在ROM，也可能发生在RAM，根据架构不同而不同。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3d4bdc31dbcf448aad7640cd1f549740.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZXJjaV9mYzIzMzY=,size_20,color_FFFFFF,t_70,g_se,x_16)

<p>
<p>
<p>
<p>
<p>

## 常量在内存的位置
- **常量概念**
	常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。
	常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
	常量就像是常规的变量，只不过常量的值在定义后不能修改。
- **如何定义常量**
	在C++中，有两种简单的定义常量的方式：
	 - 使用 **#define** 预处理器
	 - 使用**const**关键字
- **常量存放内存的位置**
	对于局部常量，存放在栈区
	对于全局常量，常量存放在全局/静态存储区
	字面值常量，存放在常量存储区（.text段），比如字符串，存放在常量区

### define与const的区别
（1）阶段：#define是在编译的预处理阶段起作用，const是在编译、运行的时候起作用。
（2）起作用的方式：#define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级错误。
（3）存储方式：#define只是进行展开，有多少地方使用就替换多少次，它定义的宏常量在内存中有若干个备份，const定义的只读常量在程序运行过程中只有一份备份。
（4）调试：const常量可以进行调试，define是不能进行调试的，因为在预编译阶段就已经替换掉了。


### const优点
（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
（2）有些集成化的调试工具可以对const进行调试，但是不能对宏常量进行调试。
（3）const可节省空间，避免不必要的内存分配，提高效率。



<p>
<p>
<p>
<p>


## 学习bss、data和rodata的区别与联系
- **.rodata**：用于存放不可修改的常量数据，一旦程序中对其修改将会出现段错误。**静态分配，只读**。
这块内存时共享的，当有多个相同进程（Process）存在时，共用一个text段。
- **.data**：也有地方叫GVAR，用来存放程序中已经初始化的非零全局变量/静态变量，若全局变量值为0，为了优化编译器会将它放在.bss段。**静态分配，分读写（RW）和只读（RO）区域。** RO区域保存常量，也称为`.constdata`。RW段则是普通非全局变量，静态变量就在其中。
- **.bss**：存放程序中未初始化和初始化为0值的全局变量/静态变量，bss段只占运行时的内存空间而不占文件空间。在程序运行的整个周期内，.bss段的数据一直存在。**静态分配，在程序开始时通常会被清零。**

区别：
- bss区（未初始化数据段）：并不给该段的数据分配空间，仅仅是记录了数据所需空间的大小。
- data区（初始化的数据段）：为数据分配空间，数据保存在目标文件中。

测试.bss和.data是否占据文件空间可通过以下程序验证：

```cpp
#include <stdio.h>

char global_arr[1024*1024];//存放在.bss段
int main()
{
	return 0;
} 
```

编译后查看大小：显然，global_arr数组占据的1M空间并没有占据文件空间。
![在这里插入图片描述](https://img-blog.csdnimg.cn/586645b9d8d84d5fbfb24a3d8b23a04a.png)
将数组改放在.data段中：

```cpp
char global_arr[1024*1024] = {4};
```
编译后查看大小：文件变成了1M多，显然，.data段上的数据是占据文件空间的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f3b69a0959be4aa89a3f9d48a3188d63.png)
注意：
- 对于未初始化的全局变量和静态变量的初始值在运行期会被赋为0。从而，达到 .bss section 用于减少目标文件的大小的目的。
- 临时变量（即局部非静态变量）既不出现在.data中，也不出现在.bss中。它由运行期栈维护。
- 严格地讲，gcc 将 C 程序（以 .c 结尾的源文件）中的未初始化的全局变量标记为COMMON，而不是放到.bsssection 中。对于 C++ 程序，无论是 gcc 还是 g++，都会将程序中未初始化的全局变量放到.bsssection 中。关于这一点，有兴趣的可以自己验证下。

参考资料：[.bss、.data 和 .rodata section 之间的区别](https://blog.csdn.net/wohenfanjian/article/details/106007978)


<p>
<p>
<p>
<p>
<p>

## free
**被free回收的内存不是立即返回给操作系统的**，它会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。

<p>

## new
### 原理
[深入C++的new](https://www.cnblogs.com/fnlingnzb-learner/p/8515183.html)

### c++的3中new
在C++中，new有三种典型的使用方法：plain new、nothrow new和placement new
- plain new
	言下之意就是普通的new，就是我们常用的new
	**plain new**在空间分配失败的情况下，抛出异常**std:bad_alloc**而不是返回NULL

- nothrow new
	notthrow new在空间分配失败的情况下是不排除异常，而是返回NULL

- placement new
	允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它唯一做的一件事情就是调用对象的构造函数。

### new包含的操作
当我们使用关键字new在堆上动态创建一个对象时（称为“new operator”或者“new expression”），它实际做了三件事：
1. 获得一块内存空间
2. 调用构造函数（placement new来实现定位构造），如果是简单类型的变量，这个会被省略
3. 返回正确的指针

new底层在分配的时候还是使用malloc
相应的，delete也有delete operator和operator delete之分，后者也是可以重载的。并且，如果重载了operator new，就应该也相应的重载operator delete，这是良好的编程习惯。

### 指定的内存中创建新对象
[C++如何在指定的内存中创建新对象](https://blog.csdn.net/gao1440156051/article/details/51442003)
**定位new（placement new）** 操作，简单地说就是使用已经分配好的内存。
1. **缓存提前分配**
	1. 为了保证通过placement new使用的缓存区的memory alignment（内存队列）
	正确准备，使用普通的new来分配它：在堆上进行分配
	```cpp
	class Task{
	public:
		int a;
	};
	char * buff = new char[sizeof(Task)]; //分配内存
	```
	（请注意auto或者static内存并非都正确地为每一个对象类型排列，所以不能将以placement new使用它们）
	
	2. **在栈上分配**
	```cpp
	class Task{
	public:
		int a;
	};
	char buff[N*sizeof(Task)]; //分配内存
	```
	
	3. **直接通过地址来使用（必须是有意义的地址）**
		在刚刚已分配的缓存区调用placement new来构造一个对象。
	```cpp
		void *buf = reinterpret_cast<void*>(0xF00F);
	```
2. 对象的分配
	在刚才已分配的缓存区调用placement new来构造一个对象
```cpp
void *buf = reinterpret_cast<void*>(0xF00F);
Task *ptask = new(buf)Task;
```

### placement new存在的理由
1. 用placement new解决buffer问题
	问题描述：用new分配的数组缓冲时，由于调用了默认构造函数，因此执行效率上不佳。若没有默认构造函数则会发生编译错误。
	如果你想在预分配的内存上创建对象，用缺省的new操作符是行不通的。要解决这个问题，可以用placement new构造。它允许构造一个新对象到预分配的内存上。

2.增大时空效率问题
	使用new操作符分配内存需要在堆中查找足够大的剩余空间，显然这个操作速度是很慢的，而且有可能出现无法分配内训的异常（空间不够）。
	placement new就可以解决这个问题。我们构造对象都是在一个预先准备好了内存缓冲区中进行，不需要查找内存，内存分配的时间是常数；而且不会出现在程序运行中途出现内存不足的异常。所以placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。    

<p>
<p>
<p>

## 自由存储区
**自由存储区与堆是否等价**
- 自由存储是C++中通过new和delete动态分配和释放对象的**抽象概念**，而堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。
- new所申请的内存区域在C++中称为自由存储区。
	藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。但是new分配的内存空间是可以制定在别的地方比如栈上，因为可以重载operator new
- 堆与自由存储区还是有区别的，**它们并非等价**

<p>
<p>
<p>

## 函数的栈帧
包含了函数的参数（至于被调用函数的参数是放在调用函数的栈帧还是被调用函数栈帧，则依赖于不同操作系统的实现）。
函数额栈帧中的局部变量以及恢复该函数的主调函数的栈帧（即前一个栈帧）所需要的数据，包含了主调函数的下一条执行指令的地址。
函数调用时所建立的栈帧包含以下的信息：
1. 函数的返回地址
	返回地址是存放在主调函数的栈帧还是被调用函数的栈帧取决于不同操作系统的实现；
2. 主调函数的栈帧信息，即栈顶和栈底
3. 为函数的局部变量分配的栈空间
4. 为被调用函数的参数分配的空间取决于不同系统的实现

### 函数调用过程
1. 从栈空间分配存储空间
2. 从实参的存储空间复制值到形参栈空间
3. 进行运算
形参在函数未调用之前都是没有分配存储空间的，在函数调用结束后，形参弹出栈空间，清除形参空间。
数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间。调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。
当函数有多个返回值的时候，不能用普通的return的方式实现，需要通过传回地址的形式进行，即地址/指针传递。

<p>
<p>
<p>

## 段错误
段错误通常发生在**访问非法内存地址的时候**，具体来说分为以下几种情况：
1. 访问非法内存地址（数组访问越界等）
2. 访问只读的内存地址（字符串常量等）
3. 栈溢出

## coredump
coredump是程序由于异常或者bug **在运行时异常退出或终止** ，在一定的条件下生成的一个叫做 **core** 的文件，这个core文件会记录程序在运行时的内存，级寄存器状态，内存指针和函数堆栈信息等等。
对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。
可以使用gdb命令对core文件进调试。 

```cpp
//mkdir coredumpTest
//vim coredumpTest.cpp

#include<stdio.h>
int main(){
    int i;
    scanf("%d",i);//正确的应该是&i,这里使用i会导致segment fault
    printf("%d\n",i);
    return 0;
}

//g++ coredumpTest.cpp -g -o coredumpTest
//./coredumpTest
//gdb [可执行文件名] [core文件名]
```


<p>
<p>
<p>

## 内存泄漏
**内存泄漏（memory leak）是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。** 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因为造成了内存的浪费。

### 内存泄漏的分类
1. **堆内存泄漏**（heap leak）
	堆内存指的程序运行中根据需要分配通过malloc、realloc、new等从堆中分配的一块内存，完成后必须通过刁永刚对应的free或者delete删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。
2. **系统资源泄漏**（Resource Leak）
	主要指程序使用系统分配内存的资源比如bitmap，handle，SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
3. **没有将基类的析构函数定义为虚函数**
	当基类指针指向子类对象时，如果基类的析构函数bushivirtual，那么子类的析构函数不会被调用，子类的资源没有正确被释放，因造成内存泄漏。

###  如何判断是否内存泄漏
**内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。**
为了判断内存是否泄漏，可以在写代码时添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄漏。
- Windows下内存泄漏检查工具：CTR库（调试运行DEBUG版程序）
- Liinux环境下内存泄漏检查工具[Valgrind](https://zhuanlan.zhihu.com/p/75416381)

### 内存泄漏的几种情况
8种，new动态创建的对象必须要用delete来撤销该对象，不然内存会泄漏。
1. **没有匹配地调用new/delete操作**
	一是在heap中创建了对象占用了内存，但是没有显式地释放所占用的内存。
	二是在类构造的时候对于可变大小的member动态分配了内存，但是在析构函数中没有对应地释放内存。

2. **没有正确地清除嵌套的对象指针**

3. **delete释放对象数组时没有使用[ ]**
	在定义了析构函数，对象数组中的元素确实需要进行有效析构（内置类型就不需要，不写[ ] 并不会出现问题），且析构函数功能完备的情况下。
	
	如果没有使用[ ] 来delete一个对象数组，那么只会析构、释放数组的第一个对象。
	
	其他元素会依然存在，但是相关内存已经要求归还了。
	而对于[ ] 中是否需要制定元素个数，在Jonathan的原始版本中会优先采用程序员指定的size。

   但是几乎所有的C++编译器都不考虑程序员的显式指定。

4. **指向对象的指针数组**
   在定义了析构函数，对象数组中的元素确实需要进行有效析构（内置类型就不需要，不写[ ]并不会出问题），且析构函数功能完备的情况下。

   即使delete [ ] ptr_arr，但是释放的只是指针所拥有的空间，指针指向的对象所拥有的空间仍然被占用，而且我们会失去对它们的控制。

   解决方法就是迭代遍历整个数组手动调用析构函数

5. **缺少拷贝构造函数 $or$  =号运算符重载**
   假设某个class内含一些指向heap空间的指针。
   
   而使用者没有提供一个显式的拷贝构造函数，此时如果此class的结构让编译器不能触发bitwise语义，那么在需要拷贝构造的场景下（比如以值传递实参转入形参），编译器就会触发memberwise语义，构造出一个逐member复制的拷贝构造函数。

   很明显，如果在memberwise copy的情况下，**会造成两个不同指针指向同一块heap空间的情况**。

   而如果此时的使用者编写了完备的析构函数，**那么就会造成两次对同一heap空间内存的释放，这会导致heap空间的崩溃。**

   heap空间崩溃，内存自然就泄漏了。

6. **返回不可控栈上空间**

   主要点在于栈上空间由操作系统管理，而不是编译器/程序员管理，所以对于一些栈空间我们是不可控的（比如函数内部临时开的栈）。

   我们可以得到一个栈空间内的地址并进行访存，但是如果这块栈的“生命”结束了，我们继续使用这个地址进行访存，就可能破坏某些操作系统功能，于是程序崩溃，内存泄漏。

7. **free( )之后没有将指针滞空**

   free( )这个C library函数只是告诉编译器/操作系统：我放弃了这块内存的控制权，你可以使用了。

   但是事实上是否放弃这块内存还是取决于程序员的行为，也就是说你可以free之后继续使用这块内存，但是此时操作系统也有管理权，于是我们就可能使用到“垃圾内存”。

   这与上一点本质上是一样的，都是访问到了受限/不合法的内存，有可能造成程序的崩溃。

8. **继承链中的base class没有将析构函数设置为virtual**



<p>
<p>
<p>




<p>
<p>
<p>

补充：[C++成员函数和成员变量存储说明](https://blog.csdn.net/tsh123321/article/details/88966421)


	




