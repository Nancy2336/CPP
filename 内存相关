# C++内存分配
## 学习C/C++程序内存的各种变量存储区域和各个区域详解
学习资料：[什么是代码区、常量区、静态区（全局区）、堆区、栈区？](https://blog.csdn.net/u014470361/article/details/79297601)
[C/C++程序内存的各种变量存储区域和各个区域详解](https://blog.csdn.net/jirryzhang/article/details/79518408)
[C/C++分区详解](https://blog.csdn.net/qq_44688854/article/details/106115161)
[C++中内存分配](https://zhuanlan.zhihu.com/p/447356030)
[堆栈、BSS段、代码段、数据段、RO、RW、ZI等概念区分](https://blog.csdn.net/dfl448866/article/details/90444228)

&emsp;内存分区：分语言层面和CPU层面进行了解，也可理解为C++在win和Linux上的内存分区。
对于运行在Linux的C++程序，C++和Linux虚拟内存的内存分布中栈区、堆区和程序代码区是相互对应的。Linux虚拟内存中data段存储了C++已经初始化的全局变量和局部变量和常量。bss段存储了未初始化的全局变量和静态变量，这些未初始化的数据在程序执行前会自动被操作系统置零。

###  语言层面
内存分区示意图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/29c0e0e18a1f466db5d9d876124f4265.png)
C/C++五大内存分区(内存由高到低)：
  1、栈区（stack）:存放函数形参和局部变量（auto类型），由编译器自动分配和释放。
  2、堆区（heap）:该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。如果程序员没有手动释放，那么程序结束时可能由OS回收。
  3、静态存储区：存放全局变量和静态变量（包括静态全局变量与静态局部变量），初始化的全局变量和静态局部变量放在一块，未初始化的放在另一块。
  4、常量区：存放字符串常量与const修饰的常量，常量区的内存是只读的，程序结束后由系统释放。
  5、代码区：存放程序的二进制代码，内存由系统管理。
  
	
	学习如上的一些内存分配机制，有助于我们理解指针的概念。

<p>
<p>
<p>

### 区域介绍
**栈区：** 存放函数内的局部变量，函数参数、返回数据、返回地址，栈区之中的数据作用范围过了之后，系统就会回收自动管理栈区的内存（分配内存、回收内存），不需要开发人员来手动管理（栈区的变化是一种动态的数据变动）。
**堆区：** 由程序员调用malloc()函数来主动申请，需要使用free()函数释放内存，若申请了堆区内存，之后忘记释放内存，很容易造成 **内存泄漏** 。
**静态区（全局区）**：静态变量和全局变量的存储区域是一起的，一旦静态区的内存被分配，静态区的内存直到程序全部结束之后才会被释放。
**常量区：** 存放常量（与程序在运行期间不改变的量，例如：10，字符串常量“abcde”，数组的名字等）
**代码区：** 存放程序的代码，即CPU执行的机器指令（二进制代码），并且是只读的。

<p>
<p>
<p>

#### 栈区
栈区是由编译器自动分配释放，存放函数的参数值、返回值和局部变量，在程序运行过程中实时分配和释放，栈区由操作系统自动管理，无需手动管理，栈区是先进后出原则。

```cpp
void test(){
	int a;
	int b = 1;
	printf("0x%p: %d\n", &a, a);
	printf("0x%p: %d\n", &b, b);
}
```
可以看到b的地址是比a小的，即栈区是从高地址向低地址增长。a没有赋值，编译器将其初始化为0（文章中说编译器不会把未初始化的局部变量初始化为0，但如果运行于debug调试模式，运行时机制会把栈空间全部初始化为0。使用局部变量时，尽量要先进行初始化，避免垃圾值造成影响）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c88ffb1ccb864d588eaf6be764d199d7.png)
##### 大小端测试
数据在内存中存放，有大端模式和小端模式。
小端模式（little-endian）：低位字节存在低地址上，高位字节存在高地址上。
大端模式（big-endian）：低位字节存在高地址上，低位字节存放在低地址上，与小端模式相反。
另外：网络字节序：TCP/IP各层协议将字节序定义为big-endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。

①利用指针判断大小端：
```cpp
static int m = 0x9876543210;
char *p = (char*) &m;

void test(){   
    printf("P  :0x%p: %x\n", p, *p);
    printf("P+1:0x%p: %x\n", p+1, *(p+1));
    printf("P+2:0x%p: %x\n", p+2, *(p+2));
    printf("P+3:0x%p: %x\n", p+3, *(p+3));
}
```
低字节10放在低地址，高字节76放在高地址，与小端模式相符。
![在这里插入图片描述](https://img-blog.csdnimg.cn/cd26e992b93d45db963cca81447e3dea.png)
②强制类型转换

```cpp
static int m = 0x9876543210;
char p = (char)m;
 
void test(){   
	printf("P: 0x%p\n", p);
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/d4613885c28840d2935f4833f2b56168.png)
③使用联合体进行判断
- 联合体的各个成员都是公用内存
- 联合体的成员不管是在哪个架构上默认都是从低地址存储的，这点非常重要。

```cpp
union endian{
	char a;
	int b;
}test;

int main()
{
	test.b = 0x87654321;
	printf("0x%p\n", test.a );
	return 0;
}
```
可以判断出所用的架构是小端的。因为test.a是联合体在内存中的第一个字节（就是在内存地址中的最低的地址），打印出了0x21说明数据的逻辑低位存储在了内存地址的低位，这就是小端了。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2e13b04feb5d431e8271395de4621fdf.png)

<p>
<p>
<p>

#### 堆区
堆区是调用malloc函数来申请内存空间，这部分空间使用完后需要调用free()函数来释放，否则可能会造成内存泄漏。需要注意的是，两个紧挨着定义的指针变量，所指向的malloc出来的两块内存并不一定的是紧挨着的，所以会产生内存碎片。
`void * malloc(size_t);`函数的输入是分配的字节的大小，返回是一个void * 型的指针，该指针指向分配空间的首地址，void * 型指针可以任意转换成其他类型的指针。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。

```cpp
void test(){   
    int *p1 = (int*)malloc(4);//申请4字节的空间 
    *p1 = 123;//空间赋值123 
	printf("0x%p: %d\n", p1, *p1);
	printf("0x%p\n", &p1);
	free(p1);
	printf("0x%p: %d\n", p1, *p1);
	p1 = NULL;//把指针p释放，避免造成野指针 
	printf("0x%p\n", p1);
}
```
`int *p1 = (int *)malloc(4);`语句申请了四个字节的空间，空间的首地址赋给了指针p1，可以看到首地址是0x0000000000c51530，存在是堆区。
`printf("0x%p\n", &p1);`指针p1本身也需要存放，p1本身是存放在栈区的0x00000000006ffde8;
`free(p1);`内存释放函数free(开辟的内存的首地址)，将内存标记为可用（并且将里面的内容清空为0，但是dev C++里没有变为0而是垃圾值），但指针还是指向这片空间，比较安全的做法是`p1 = NULL;`把p1指针释放，避免造成野指针。
![在这里插入图片描述](https://img-blog.csdnimg.cn/9d4cf7bddd104e2fb12e1b6044bb352e.png)

```cpp
void test(){
	int *p1 = (int *)malloc(4);
	int *p2 = (int *)malloc(4);
	printf("p1: 0x%p\n", p1);
	printf("p2: 0x%p\n", p2);
}
```
p2的地址高于p1的地址，验证了堆区是从低地址向高地址增长的，后申请的空间地址会依次增加。
![在这里插入图片描述](https://img-blog.csdnimg.cn/38d9b6f84694416aa07cfe5da9dd07ac.png)

> 内存溢出（out of memory）；通俗理解就是内存不够，通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了主机内安装的内存所承受大小，就叫内存溢出。

拓展资料（申请分配大内存）：[mmap()函数](https://blog.csdn.net/yangle4695/article/details/52139585)
          
<p>
<p>
<p>

##### free
**被free回收的内存不是立即返回给操作系统的**，它会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。

<p>

##### new
###### 原理
[深入C++的new](https://www.cnblogs.com/fnlingnzb-learner/p/8515183.html)

###### c++的3中new
在C++中，new有三种典型的使用方法：plain new、nothrow new和placement new
- plain new
	言下之意就是普通的new，就是我们常用的new
	**plain new**在空间分配失败的情况下，抛出异常**std:bad_alloc**而不是返回NULL





<p>
<p>
<p>

##### 内存碎片
&emsp;一种解释：为了减少内存碎片的产生，编译器可能会将堆区又分为block和heap区，block由一系列大小相等的内存块组成。分配内存时先在block中分配，如果block占满则从heap区中分配。同时block的大小和个数可以通过文件进行配置，使之达到一个合适的状态。

```cpp
#define BLOCK_List\
	BLOCK(20, 80)\
	BLOCK(300, 80)
```


<p>
<p>
<p>

##### 内存泄漏
内存泄漏（Memory Leak）：是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

<p>
<p>
<p>

##### 内存溢出


<p>
<p>
<p>

#### 静态区
和“栈”一样，通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。

```cpp
static int a;
int  c;

void test(){
	static int b = 1;
	b++;
	printf("b: 0x%p: %d\n", &b, b);
}

int main()
{
	printf("a: 0x%p: %d\n", &a, a);
	printf("c: 0x%p: %d\n", &c, c);
	for(int i = 0; i < 5; i++)
		test();	
	return 0;
}
```
a是静态全局变量，b是静态局部变量，c是全局变量，它们都存储在静态区，a和c并未初始化，打印出来的值都是0，说明编译器自动将它们初始化为0。b在for循环中打印5次，但实际是b只初始化1次，后面每次调用b都是上次的值+1且b的地址一直是不变的，编译器只会为第一次初始化的b分配内存。
![在这里插入图片描述](https://img-blog.csdnimg.cn/45565dbf276540eaa37f5808b6f8c63c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZXJjaV9mYzIzMzY=,size_13,color_FFFFFF,t_70,g_se,x_16)

#### 常量区
和全局/静态存储区一样，通常是用于那些在编译期间就能确定存储大小的常量的存储区，并且在程序运行期间，存储区内常量是全局可见的。这是一块比较特殊的存储区，它们里面存放的是常量，不允许被修改。
下面来分析一句代码：`char *p = "abcde"`。这句代码和`char *p; p = "abcde"`是等价的。
这两种定义方式的具体意思是：定义一个char * 型的指针p，p存放的是字符串常量“abcde”的首地址，字符串常量“abcde”是存放在常量区的，也就是p指向常量区，那么p指向的区域里面的内容是不可以修改的，只可以用*p来读取p指向的内容，或者将p指向其他区域。

测试：

```cpp
void test(){
	char *p = "abcde";
	printf("0x%p: %s\n", p, p);//打印指针p的地址和p指向的字符串内容
	p = "qdwoed";
	printf("0x%p: %s\n", p, p);//打印指针p的地址和p指向的字符串内容
	p[0] = 'c';			       //尝试修改p指向的第一个字符
	printf("0x%p: %s\n", p, p);//打印指针p的地址和p指向的字符串内容 
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/ad87fd67769f467683053a02bfa55f3a.png)
可以看到"abcde"字符串常量放在0x0000000000488006区域，p 指针指向该区域，然后将 p 指针指向"qdwoed”字符串常量的首地址0x0000000000488016。当尝试修改 p 指向的第一个字符时，程序运行异常并退出，因为常量区的内容不可以修改。
`char str[] = "abcde"`这句话是定义了一个字符数组，但这个str[]数组是存放在栈区的，然后再把字符串变量"abcde"拷贝到栈区的str数组内，那么此时的str是可以修改的。

```cpp
void test(){
	char str[] = "abcde";
	printf("0x%p: %s\n", str, str);
	str[0] = 'b';
	printf("0x%p: %s\n", str, str);
}
```
可以看到str是指向栈区的地址：0x00000000008efde0，且指向的内容可以被修改，第一个字符'a'被修改为'b'。
![在这里插入图片描述](https://img-blog.csdnimg.cn/e4a768949cae4ed5b696dee330dc2913.png)



#### 代码区 
- 代码区的内存是由系统控制的
- 代码区的存放：程序中的函数编译后的代码，即cpu执行的机器指令，只读。
- 代码区的地址：函数的地址，程序的入口地址，程序的名字。
	函数的名称也是一个指针，可以通过查询函数名称所处的内存地址，查询函数存放的区域。
```cpp
void print(){
	printf("hello\n");
}
void test(){
	printf("print add: 0x%p\n", print);//打印 print()函数的存放地址 
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/7cbbb195e39c436fa82c421b29457e5e.png)

<p>
<p>
<p>


#### 区域注意的点

①**C/C++不提供垃圾回收机制，因此需要对堆中的数据进行及时销毁，防止内存泄漏**，使用 free 和 delete 销毁 new 和 malloc 申请的堆内存，而栈内存是动态释放。

②堆区一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式类似于链表。

③普通局部变量保存在堆栈中，每个线程都会有自己的栈，但是堆空间是共用的。

④全局变量、静态变量保存在全局数据区，初始化的和未初始化的分别保存在一起。

<p>
<p>
<p>
<p>
<p>
<p>

### CPU层面
对于CPU来说，程序在内存中的分区定义略有不同。一个程序在内存中的分区可分：
1、text segment（代码段）：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码
2、data segment（数据段）：存储程序中以初始化的全局变量和静态变量
3、bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。对于未初始化的的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0
4、heap（堆）：当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。堆的起始地址由mm_struct结构体中的start_brk标识，结束地址由brk标识。
5、stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。

<p>
<p>

#### 文件分区
一个可执行的程序文件可分为三部分：text 、data、bss。这三部分是在编译时就确定分配的空间，属于静态空间，所以被包含在可执行文件里；其余动态空间（局部变量，new分配的空间）在程序执行时分配，所以不包含在可执行文件里。
 1、text segment（代码段）：用来存放代码，一般是只读的区域;
 2、data segment（数据段）：用来存放const修饰的常量、初始化的全局变量、静态变量，只初始化一次。data又可分为RO_data(const修饰的常量)和RW_data(初始化的全局变量、静态变量);
 3、bss segment：bss又叫ZI-data，用来存放未初始化的全局变量和静态变量，以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。

<p>
<p>
	
#### 静态区域
##### **text segment（代码段）**
代码段（又称为Code代码域）存放程序执行代码的一段内存区域，这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读（某些架构也允许修改）。
- 文本区存储程序的机器代码（二进制代码）
- 这块内存是**共享**的，当多个相同进程（Process）存在时，共用同一个text段
- 所有函数都是存储在代码段
- 代码段中的指令包括操作码和被操作对象（或对象地址引用）
	- 只读变量：只包含在代码段中
	- 局部变量：在堆栈区分配内存空间并引用
	- 全局变量：引用data段或bss段中的地址

<p>

###### 常量数据段（.rodata）
RO表示read only，用于存放不可修改的常量数据，一旦程序中对其修改将会出现段错误。
用于维护只读数据，比如：常量字符串、带 const 修饰的全局变量和静态变量等，在目标文件中占据空间。
（1）程序中的常量不一定就放在.rodata里，有的立即数和指令编码放在.text中。
（2）对于字符串常量，若程序中存在重复的字符串，编译器会**自动去掉重复的字符串**，保证一个字符串在一个可执行文件（EXE/SO）中只存在一份拷贝。
（3）.rodata是在多个进程间共享的。
（4）想将数据（变量）放在.rodata区只需要加上const属性修饰即可

拓展：[七种寻址方式](https://blog.csdn.net/u011587070/article/details/81540987)

<p>
<p>

##### data segment（数据段）
&emsp;存储程序中**已初始化**的**全局变量**和**静态变量**。也有地方叫GVAR(global value)
   - data又可以分为读写区域(RW_data)和只读区域(RO_data)
	- RO段：ReadOnly data，即只读数据域，它指程序中用到的只读数据，全局变量，例如C语言中const关键字定义的全局变量就是典型的RO-data。RO段保存常量所以也被称为`.constdata`。
	- RW段：ReadWrite data，即可读写数据域，它指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。例如全局变量或者静态变量，且定义时赋予“非0值”给该变量进行初始化。	- 
RW_data：

<p>
<p>

##### bss segment（bss段）
&emsp; 存储未初始化的全局变量和静态变量，以及所有被初始为0的全局变量和静态变量，程序运行main之前时会统一清零。**即未初始化的全局变量和静态变量编译器会初始化为0**

<p>
<p>
<p>
<p>

#### 动态区域
&emsp;**heap（堆）**：当进程未调用malloc时是没有堆段的，**只有调用malloc时采用分配一个堆**，并且在程序运行过程中可以动态增加堆的大小（移动break指针），**从低地址向高地址增长**。**分配小内存时使用该区域**。
&emsp;**memory mapping segment（映射区）：** 存储动态链接库等文件、申请大内存（malloc时调用mmap函数），位于堆和栈之间。
&emsp;**stack（栈）**：使用栈空间存储函数的返回地址、参数、局部变量、返回值。**从高地址向低地址增长**。**在创建进程时会有一个最大栈大小，** Linux可以通过ulimit命令指定。.esp始终指向栈顶。
	
- 其他
	- 栈的大小是有限的，通常Visual C++编译器默认栈的大小为1MB
	- 堆的大小几乎不受限制，理论上每个程序最大可达4GB。
	- 堆和栈相向而生，栈和堆有个临界点，称为stkbrk。
	- 相同：堆、栈都是动态分配内存，两者空间的大小是可变的。
	- 不同：每个线程都有自己的栈，但是堆空间是共用的。


<p>

##### 堆、栈
|     区别                                                             |        栈               |      堆               |
| ------------------------------------------------------------| --------------------  |--------------------|
|管理方式|编译器自动分配释放|程序员分配释放，容易产生内存泄漏|
|空间大小|一般有一定的空间限制（比如1M）|在32位系统下堆内存可以达到4G大小，空间足够大|
|内存碎片|不存在碎片问题|存在内存碎片问题|
|生长方向|栈向着内存地址减小的方向生长（由高到低）|堆向着内存地址增加的方向生长（由低到高）|
|分配方法|静态分配，由编译器完成（比如分配局部变量）|动态分配由malloc函数进行分配，无静态分配|
|分配效率|栈是操作系统提供的数据结构，计算机会在底层对栈提供支持（比如分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行），分配效率高|堆是C/C++函数库提供的，实现机制比较复杂（比如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大的空间，当没有合适的空间（比如内存碎片太多）时可能通过系统调用去增加堆段的内存空间），分配效率较低|
|系统响应|只要栈的剩余空间大于所申请空间就可以分配成功，否则就抛出栈溢出的异常|操作系统存在一个记录空闲内存地址的链表，分配堆内存时会遍历链表寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。大多数系统还会在这块内存空间中的首地址记录本次分配的大小，这样delete语句才能正确释放本内存空间。由于找到的堆节点大小不一定正好等于申请内存的大小，因此系统会自动将多余的部分重新放入空闲链表中|
|存储内容|在函数调用时，第一个入栈的是函数调用语句的下一条可执行语句的地址，然后是函数的各个参数，最后是函数中的局部变量。本次函数调用结束后，按照先进后出的方式依次弹出局部变量、函数参数和栈顶指针。程序根据栈顶指针指向的地址继续运行|一般在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排|
|内存越界|栈内存越界情况大多出现在数组下标超过数组定义长度，后果导致覆盖其他变量|堆内存越界主要是操作的内存超过了malloc/calloc/new等在堆上分配内存的内存大小，后果导致下次分配时抛出`_int_malloc`错误，中止|

和栈相比，堆存在以下缺点：
- 由于大量new/delete的使用容易产生大量的内存碎片问题
- 没有专门的系统支持，分配效率较低
- 可能引发用户态和核心态的切换

总结：
- stack：按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。
- heap：自由申请的空间，按内存地址从低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。

<p>
<p>
<p>

#### 总结
以上几个概念的对应关系如下表中所示：
备注:粉色部分的code和RO_data文字颜色为灰色，表示可能发生在ROM，也可能发生在RAM，根据架构不同而不同。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3d4bdc31dbcf448aad7640cd1f549740.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZXJjaV9mYzIzMzY=,size_20,color_FFFFFF,t_70,g_se,x_16)

<p>
<p>
<p>
<p>
<p>

## 常量在内存的位置
- **常量概念**
	常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。
	常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
	常量就像是常规的变量，只不过常量的值在定义后不能修改。
- **如何定义常量**
	在C++中，有两种简单的定义常量的方式：
	 - 使用 **#define** 预处理器
	 - 使用**const**关键字
- **常量存放内存的位置**
	对于局部常量，存放在栈区
	对于全局常量，常量存放在全局/静态存储区
	字面值常量，存放在常量存储区（.text段），比如字符串，存放在常量区

### define与const的区别
（1）阶段：#define是在编译的预处理阶段起作用，const是在编译、运行的时候起作用。
（2）起作用的方式：#define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级错误。
（3）存储方式：#define只是进行展开，有多少地方使用就替换多少次，它定义的宏常量在内存中有若干个备份，const定义的只读常量在程序运行过程中只有一份备份。
（4）调试：const常量可以进行调试，define是不能进行调试的，因为在预编译阶段就已经替换掉了。


### const优点
（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
（2）有些集成化的调试工具可以对const进行调试，但是不能对宏常量进行调试。
（3）const可节省空间，避免不必要的内存分配，提高效率。



<p>
<p>
<p>
<p>


## 学习bss、data和rodata的区别与联系
- **.rodata**：用于存放不可修改的常量数据，一旦程序中对其修改将会出现段错误。**静态分配，只读**。
这块内存时共享的，当有多个相同进程（Process）存在时，共用一个text段。
- **.data**：也有地方叫GVAR，用来存放程序中已经初始化的非零全局变量/静态变量，若全局变量值为0，为了优化编译器会将它放在.bss段。**静态分配，分读写（RW）和只读（RO）区域。** RO区域保存常量，也称为`.constdata`。RW段则是普通非全局变量，静态变量就在其中。
- **.bss**：存放程序中未初始化和初始化为0值的全局变量/静态变量，bss段只占运行时的内存空间而不占文件空间。在程序运行的整个周期内，.bss段的数据一直存在。**静态分配，在程序开始时通常会被清零。**

区别：
- bss区（未初始化数据段）：并不给该段的数据分配空间，仅仅是记录了数据所需空间的大小。
- data区（初始化的数据段）：为数据分配空间，数据保存在目标文件中。

测试.bss和.data是否占据文件空间可通过以下程序验证：

```cpp
#include <stdio.h>

char global_arr[1024*1024];//存放在.bss段
int main()
{
	return 0;
} 
```

编译后查看大小：显然，global_arr数组占据的1M空间并没有占据文件空间。
![在这里插入图片描述](https://img-blog.csdnimg.cn/586645b9d8d84d5fbfb24a3d8b23a04a.png)
将数组改放在.data段中：

```cpp
char global_arr[1024*1024] = {4};
```
编译后查看大小：文件变成了1M多，显然，.data段上的数据是占据文件空间的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f3b69a0959be4aa89a3f9d48a3188d63.png)
注意：
- 对于未初始化的全局变量和静态变量的初始值在运行期会被赋为0。从而，达到 .bss section 用于减少目标文件的大小的目的。
- 临时变量（即局部非静态变量）既不出现在.data中，也不出现在.bss中。它由运行期栈维护。
- 严格地讲，gcc 将 C 程序（以 .c 结尾的源文件）中的未初始化的全局变量标记为COMMON，而不是放到.bsssection 中。对于 C++ 程序，无论是 gcc 还是 g++，都会将程序中未初始化的全局变量放到.bsssection 中。关于这一点，有兴趣的可以自己验证下。

参考资料：[.bss、.data 和 .rodata section 之间的区别](https://blog.csdn.net/wohenfanjian/article/details/106007978)



补充：[C++成员函数和成员变量存储说明](https://blog.csdn.net/tsh123321/article/details/88966421)


	




